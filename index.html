<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RDR2 — True-ish Map with Search & Routing</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link href="https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&family=IM+Fell+English&display=swap" rel="stylesheet">

<style>
  html,body,#map{height:100%;margin:0;padding:0;background:#efe0c9;font-family:"IM Fell English",serif}
  #map{position:relative}
  .parchment{pointer-events:none;position:absolute;inset:0;background-image:
    linear-gradient(rgba(30,20,10,0.04),rgba(20,10,5,0.04)),
    url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="g"><feTurbulence baseFrequency="0.9" numOctaves="1" stitchTiles="stitch"/><feColorMatrix type="saturate" values="0.1"/></filter><rect width="100%" height="100%" filter="url(%23g)" opacity="0.06" fill="%23ffffff"/></svg>');mix-blend-mode:multiply;z-index:700}
  #map:after{content:"";pointer-events:none;position:absolute;inset:0;background:radial-gradient(60% 60% at 50% 40%,rgba(0,0,0,0)40%,rgba(0,0,0,0.28)100%);z-index:900;mix-blend-mode:multiply}
  .rdr2-tiles{filter:grayscale(0.6)contrast(1.02)sepia(0.6)brightness(0.92)hue-rotate(-8deg)}
  /* Controls */
  .controls{position:absolute;left:12px;top:12px;z-index:1300;background:rgba(18,12,8,0.68);color:#f6ead3;padding:10px;border-radius:10px;font-size:13px;box-shadow:0 6px 20px rgba(0,0,0,0.6);width:220px}
  .controls h1{font-family:"IM Fell English SC",serif;margin:0 0 8px 0;font-size:16px}
  .controls button{display:block;width:100%;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.03);color:#f6ead3;padding:8px;border-radius:8px;margin-top:6px;cursor:pointer}
  .controls label{display:block;color:#e9dcc7;margin-top:6px}
  /* Search box */
  .search-wrap{display:flex;gap:6px}
  #search{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.15);background:rgba(255,248,234,0.92);font-family:"IM Fell English",serif}
  #searchBtn{padding:8px;border-radius:8px;border:none;background:#2b1a11;color:#fff;cursor:pointer}
  .results{position:absolute;left:12px;top:120px;z-index:1400;width:260px;background:rgba(20,14,10,0.94);color:#efe2cc;border-radius:8px;padding:6px;display:none;box-shadow:0 8px 28px rgba(0,0,0,0.6)}
  .results .item{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03);cursor:pointer}
  .results .item:last-child{border-bottom:none}
  .results .item:hover{background:rgba(255,255,255,0.02)}
  /* Compass */
  .compass{position:absolute;right:12px;top:12px;z-index:1300;width:64px;height:64px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:rgba(18,12,8,0.6);color:#f3e7d0;font-weight:700;font-family:"IM Fell English SC",serif;box-shadow:0 6px 16px rgba(0,0,0,0.5)}
 
  /* Player */
  .player-marker{width:38px;height:38px;border-radius:50%;background:radial-gradient(circle at 30% 30%,#fff 0%,rgba(255,255,255,0.16)10%,rgba(255,0,0,0.08)40%,rgba(0,0,0,0.22)100%);border:2px solid rgba(25,12,8,0.9);box-shadow:0 6px 16px rgba(0,0,0,0.6);transform-origin:center;display:flex;align-items:center;justify-content:center;position:relative;animation:pulse 2s infinite;}
  @keyframes pulse {0%{transform:scale(1);}50%{transform:scale(1.05);}100%{transform:scale(1);}}
  .player-marker:after{content:"";position:absolute;width:6px;height:6px;background:#ff0000;border-radius:2px;box-shadow:0 0 8px rgba(255,0,0,0.9)}
  /* shop icon style */
  .shop-icon { width:30px;height:30px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:#000;color:#fff;border:2px solid rgba(255,255,255,0.04);box-shadow:0 6px 12px rgba(0,0,0,0.6);font-size:16px; }
  /* popup style */
  .leaflet-popup-content-wrapper { background: rgba(20,14,10,0.95); color:#efe2cc; border-radius:6px; box-shadow:0 8px 20px rgba(0,0,0,0.6); }
  .leaflet-popup-content { font-size:13px; font-family:"IM Fell English",serif; }
  /* zoom control tweaks */
  .leaflet-control-zoom { box-shadow:0 4px 12px rgba(0,0,0,0.45); border-radius:8px; overflow:hidden; }
  .leaflet-control-zoom a { background: rgba(18,12,8,0.62); color:#f5e9d6; padding:8px 10px; display:block; text-decoration:none }
  /* Nominatim attribution */
  .search-attrib { font-size:11px;color:#cfc1a7;margin-top:6px }
  /* Loading spinner */
  .loading {position:absolute;top:50%;left:50%;z-index:1500;color:#f6ead3;font-size:16px;display:none;}
  @media (max-width:420px){ .controls{width:190px;left:8px;} .results{left:8px;width:220px} .compass{right:8px;top:80px;} .legend{left:8px;bottom:80px;} }
</style>
</head>
<body>
<div id="map"></div>
<div class="parchment"></div>

<div class="controls" id="controls">
  <h1>RDR2 • Map</h1>
  <div style="margin-bottom:6px">Search places</div>
  <div class="search-wrap">
    <input id="search" placeholder="Find town, shop, address..." autocomplete="off" aria-label="Search input"/>
    <button id="searchBtn" aria-label="Search button">Go</button>
  </div>
  <div class="search-attrib">Powered by Nominatim / OSM</div>
  <label><input type="checkbox" id="follow" checked /> Follow me</label>
  <label><input type="checkbox" id="autoFetch" checked /> Auto-fetch features</label>
  <label><input type="checkbox" id="showRivers" checked /> Show rivers</label>
  <label><input type="checkbox" id="showRoads" checked /> Show roads</label>
  <label><input type="checkbox" id="showRails" checked /> Show rails</label>
  <button id="recenter">Recenter</button>
  <button id="clearRoute">Clear Route</button>
</div>

<div class="results" id="results"></div>
<div class="compass" id="compass">N</div>

<div class="legend" id="legend">
  <div style="font-weight:700;margin-bottom:6px">Legend</div>
  <div class="item"><span class="swatch" style="background:#2fa6e6"></span> Rivers</div>
  <div class="item"><span class="swatch" style="background:#6c4028"></span> Roads (solid = main)</div>
  <div class="item"><span class="swatch" style="background:#222"></span> Rails (dashed)</div>
  <div class="item"><span style="width:18px;height:18px;border-radius:50%;background:#000;display:inline-block;border:2px solid #fff;"></span> Shops</div>
  <div class="item"><span class="swatch" style="background:#ff0000"></span> Route</div>
</div>

<div class="credit" style="position:absolute;right:12px;bottom:8px;z-index:1300;color:#eae1d0;font-size:11px">Tiles © OpenStreetMap contributors</div>
<div class="loading" id="loading">Loading...</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/osmtogeojson@3.0.0/osmtogeojson.js"></script>

<script>
// --- Map Init ---
const map = L.map('map', { zoomControl: true, minZoom: 3, maxZoom: 19 }).setView([0, 0], 2);
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '' }).addTo(map);
map.getPane('tilePane').classList.add('rdr2-tiles');
L.tileLayer('https://tiles.wmflabs.org/hillshading/{z}/{x}/{y}.png', { maxZoom: 15, opacity: 0.28 }).addTo(map);

// --- Player ---
const playerIcon = L.divIcon({ className: 'player-marker', iconSize: [38, 38], iconAnchor: [19, 19] });
const playerMarker = L.marker([0, 0], { icon: playerIcon }).addTo(map);
const accuracyCircle = L.circle([0, 0], { radius: 0, color: '#ff0000', fillColor: '#ff0000', opacity: 0.3, fillOpacity: 0.1 }).addTo(map);
playerMarker.setZIndexOffset(3000);

// --- Follow/Compass ---
const followCheckbox = document.getElementById('follow');
let follow = followCheckbox.checked;
followCheckbox.addEventListener('change', e => follow = e.target.checked);
const compassEl = document.getElementById('compass');
function headingToCompass(h) { if (!h || isNaN(h)) return 'N'; const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']; return dirs[Math.round(((h % 360) / 45) + 8) % 8]; }
let firstLocation = true;
let geoRetryCount = 0;
const maxGeoRetries = 3;

function startGeolocation() {
  if (navigator.geolocation) {
    navigator.geolocation.watchPosition(
      pos => {
        const lat = pos.coords.latitude, lng = pos.coords.longitude, acc = Math.min(pos.coords.accuracy, 50), speed = pos.coords.speed, heading = pos.coords.heading;
        const highAccuracy = pos.coords.accuracy <= 20; // Consider <20m as high accuracy
        const adjustedAcc = highAccuracy ? Math.max(acc, 10) : acc; // Shrink to 10m min if high accuracy
        snapToRoadOrPath(lat, lng, speed).then(snapped => {
          const finalLatLng = snapped || [lat, lng];
          playerMarker.setLatLng(finalLatLng);
          accuracyCircle.setLatLng(finalLatLng).setRadius(adjustedAcc);
          if (follow) map.setView(finalLatLng, Math.max(map.getZoom(), 16), { animate: true });
          if (firstLocation) {
            map.setView(finalLatLng, 16, { animate: true });
            firstLocation = false;
            geoRetryCount = 0; // Reset retries on success
          }
          compassEl.textContent = headingToCompass(heading);
        });
      },
      err => {
        console.warn('Geolocation error:', err);
        if (err.code === 1 && geoRetryCount < maxGeoRetries) {
          geoRetryCount++;
          setTimeout(startGeolocation, 2000); // Retry after 2s
          alert(`Location access denied. Retrying (${geoRetryCount}/${maxGeoRetries})... Please allow location access.`);
        } else {
          alert('Geolocation failed: ' + err.message + '. Ensure location services are enabled.');
        }
      },
      { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
    );
  } else {
    alert('Geolocation not supported in this browser.');
  }
}
startGeolocation();

// --- Snap to Road/Path ---
async function snapToRoadOrPath(lat, lng, speed) {
  if (!speed || isNaN(speed)) return null; // No speed data, don't snap
  const isDriving = speed > 5; // >5 m/s (~18 km/h) = driving
  const isWalking = speed < 2; // <2 m/s (~7.2 km/h) = walking
  if (!isDriving && !isWalking) return null; // Ambiguous speed, don't snap
  const queryType = isDriving ? 'highway~"^motorway|trunk|primary|secondary|tertiary|residential|service$"' : 'highway~"^footway|path|track$"';
  const bounds = L.latLngBounds(L.latLng(lat - 0.0005, lng - 0.0005), L.latLng(lat + 0.0005, lng + 0.0005));
  const query = `[out:json][timeout:10];way[${queryType}](${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()});(._;>;);out geom;`;
  try {
    const servers = ['https://overpass-api.de/api/interpreter', 'https://overpass.kumi.systems/api/interpreter'];
    let res;
    for (const server of servers) {
      res = await fetch(server, { method: 'POST', headers: { 'Content-Type': 'text/plain;charset=UTF-8' }, body: query });
      if (res.ok) break;
    }
    if (!res.ok) return null; // No valid response
    const geo = osmtogeojson(await res.json());
    let closestPoint = null, minDist = Infinity;
    geo.features.forEach(f => {
      if (f.geometry.type === 'LineString') {
        const coords = f.geometry.coordinates.map(c => [c[1], c[0]]);
        for (let i = 0; i < coords.length - 1; i++) {
          const point = L.Projection.SphericalMercator.project(L.latLng(lat, lng));
          const a = L.Projection.SphericalMercator.project(L.latLng(coords[i]));
          const b = L.Projection.SphericalMercator.project(L.latLng(coords[i + 1]));
          const closest = L.LineUtil.closestPointOnSegment(point, a, b);
          const dist = L.latLng(lat, lng).distanceTo(L.Projection.SphericalMercator.unproject(closest));
          if (dist < minDist && dist < 50) { // Within 50m
            minDist = dist;
            closestPoint = L.Projection.SphericalMercator.unproject(closest);
          }
        }
      }
    });
    return closestPoint;
  } catch (e) {
    console.warn('Snap error:', e);
    return null;
  }
}

// --- Layers ---
const riversLayer = L.geoJSON(null, { style: () => ({ color: '#2fa6e6', weight: 3, opacity: 0.95 }) }).addTo(map);
const roadsLayer = L.geoJSON(null, { style: roadStyle, onEachFeature: roadOnEach }).addTo(map);
const railsLayer = L.geoJSON(null, { style: () => ({ color: '#221e1b', weight: 2.2, opacity: 0.95, dashArray: '12 8' }) }).addTo(map);
const shopsLayer = L.layerGroup().addTo(map);
const placesLayer = L.layerGroup().addTo(map);

// Layer Toggles
document.getElementById('showRivers').addEventListener('change', e => e.target.checked ? map.addLayer(riversLayer) : map.removeLayer(riversLayer));
document.getElementById('showRoads').addEventListener('change', e => e.target.checked ? map.addLayer(roadsLayer) : map.removeLayer(roadsLayer));
document.getElementById('showRails').addEventListener('change', e => e.target.checked ? map.addLayer(railsLayer) : map.removeLayer(railsLayer));

// --- Roads Styling ---
function roadStyle(feature) {
  const h = feature.properties?.tags?.highway || '';
  let w = 2, dash = null;
  if (['motorway', 'trunk'].includes(h)) w = 6;
  else if (h === 'primary') w = 5;
  else if (h === 'secondary') w = 4;
  else if (h === 'tertiary') w = 3.5;
  else if (['residential', 'service'].includes(h)) w = 2;
  if (['track', 'path', 'footway', 'bridleway'].includes(h)) dash = '6,8';
  return { color: '#6c4028', weight: Math.max(1.6, w), dashArray: dash, opacity: 0.98, lineCap: 'round', lineJoin: 'round' };
}
function roadOnEach(feature, layer) {
  if (!feature.geometry) return;
  const coords = (feature.geometry.coordinates || []).map(c => [c[1], c[0]]);
  const inner = L.polyline(coords, { color: '#f1d8b0', weight: Math.max(1, (layer.options.weight || 2) - 1.6), opacity: 0.55, interactive: false, lineCap: 'round', lineJoin: 'round' }).addTo(map);
  layer._inner = inner;
}
function clearRoads() { roadsLayer.eachLayer(l => { if (l._inner) map.removeLayer(l._inner); }); roadsLayer.clearLayers(); }

// --- Fetch OSM Features ---
const autoFetchCheckbox = document.getElementById('autoFetch');
const loadingEl = document.getElementById('loading');
let fetchTimeout = null;
let lastFetchError = 0;
const FETCH_COOLDOWN = 120000; // 2 minutes
async function fetchOSMFeatures(bounds) {
  if (Date.now() - lastFetchError < FETCH_COOLDOWN) {
    console.log('Fetch on cooldown - skipping');
    return;
  }
  loadingEl.style.display = 'block';
  const pad = 0.18;
  const s = bounds.getSouth() - (bounds.getNorth() - bounds.getSouth()) * pad;
  const n = bounds.getNorth() + (bounds.getNorth() - bounds.getSouth()) * pad;
  const w = bounds.getWest() - (bounds.getEast() - bounds.getWest()) * pad;
  const e = bounds.getEast() + (bounds.getEast() - bounds.getWest()) * pad;
  const query = `[out:json][timeout:30];
    (
      way["highway"](${s},${w},${n},${e});
      way["waterway"](${s},${w},${n},${e});
      way["railway"](${s},${w},${n},${e});
      node["place"~"city|town|village|hamlet"](${s},${w},${n},${e});
      node["shop"](${s},${w},${n},${e});
      node["amenity"~"marketplace|bank|post_office|pharmacy|pub|restaurant"](${s},${w},${n},${e});
    );(._;>;);out body;`;
  try {
    const servers = ['https://overpass-api.de/api/interpreter', 'https://overpass.kumi.systems/api/interpreter'];
    let res;
    for (const server of servers) {
      res = await fetch(server, { method: 'POST', headers: { 'Content-Type': 'text/plain;charset=UTF-8' }, body: query });
      if (res.ok) break;
    }
    console.log('Overpass status:', res.status);
    if (!res.ok) {
      const errorMsg = `Overpass error: ${res.status} (${res.statusText})`;
      throw new Error(errorMsg);
    }
    const geo = osmtogeojson(await res.json());
    const roads = [], rivers = [], rails = [], shops = [], places = [];
    geo.features?.forEach(f => {
      const t = f.properties?.tags || {};
      if (t.highway) roads.push(f);
      else if (t.railway) rails.push(f);
      else if (t.waterway) rivers.push(f);
      else if (t.shop || t.amenity) { if (f.geometry?.type === 'Point') shops.push(f); }
      else if (t.place) places.push(f);
    });
    clearRoads(); if (roads.length) roadsLayer.addData({ type: 'FeatureCollection', features: roads });
    riversLayer.clearLayers(); if (rivers.length) riversLayer.addData({ type: 'FeatureCollection', features: rivers });
    railsLayer.clearLayers(); if (rails.length) railsLayer.addData({ type: 'FeatureCollection', features: rails });
    shopsLayer.clearLayers();
    if (shops.length > 200) shops = shops.slice(0, 200);
    shops.forEach(node => {
      const t = node.properties?.tags || {};
      const name = t.name || (t.shop || t.amenity) || 'shop';
      const lat = node.geometry.coordinates[1], lon = node.geometry.coordinates[0];
      const type = t.shop || t.amenity || '';
      const icon = createShopIcon(type);
      L.marker([lat, lon], { icon }).addTo(shopsLayer)
        .bindPopup(`<b style="font-family:'IM Fell English SC',serif;">${escapeHtml(name)}</b><br/><small style="font-family:'IM Fell English',serif;color:#f0d9c5;">${escapeHtml(type)}</small>`);
    });
    placesLayer.clearLayers();
    if (places.length > 100) places = places.slice(0, 100);
    places.forEach(p => {
      if (!p.geometry || p.geometry.type !== 'Point') return;
      const lat = p.geometry.coordinates[1], lon = p.geometry.coordinates[0];
      const t = p.properties?.tags || {};
      const name = t.name || '', placeType = t.place || '';
      if (name) {
        const label = L.marker([lat, lon], { icon: L.divIcon({ className: 'town-label', html: `<div style="padding:4px 6px;border-radius:6px;background:rgba(255,248,234,0.92);border:1px solid rgba(0,0,0,0.06);font-family:'IM Fell English SC',serif;font-size:${placeType === 'city' ? 16 : 14}px;color:#2d1a10;">${escapeHtml(name)}</div>`, iconAnchor: [0, 0] }) }).addTo(placesLayer);
        label.bindPopup(`<b style="font-family:'IM Fell English SC',serif;">${escapeHtml(name)}</b><br/><small style="font-family:'IM Fell English',serif;color:#f0d9c5;">${escapeHtml(placeType)}</small>`);
      }
    });
  } catch (e) {
    console.error('Fetch error details:', e.message);
    lastFetchError = Date.now();
    autoFetchCheckbox.checked = false;
    alert(`Failed to fetch map features: ${e.message}. Try disabling auto-fetch or waiting a few minutes. Check console for details.`);
    setTimeout(() => { if (autoFetchCheckbox.checked) fetchOSMFeatures(map.getBounds()); }, FETCH_COOLDOWN); // Retry after cooldown
  } finally {
    loadingEl.style.display = 'none';
  }
}
function debounceFetch() {
  if (fetchTimeout) clearTimeout(fetchTimeout);
  fetchTimeout = setTimeout(() => { if (autoFetchCheckbox.checked) fetchOSMFeatures(map.getBounds()); }, 2000);
}
map.on('moveend', debounceFetch);

// --- Shop Icon ---
function createShopIcon(type) {
  let symbol = '$';
  if (type.includes('gun') || type === 'weapons') symbol = '🔫';
  else if (type.includes('horse') || type === 'stable') symbol = '🐴';
  else if (type === 'bank') symbol = '🏦';
  else if (type === 'pub' || type === 'restaurant') symbol = '🍺';
  else if (type === 'pharmacy') symbol = '💊';
  else if (type) symbol = type[0].toUpperCase();
  return L.divIcon({ className: 'shop-icon', html: `<span>${symbol}</span>`, iconSize: [30, 30], iconAnchor: [15, 15] });
}

// --- Search ---
const searchInput = document.getElementById('search'), searchBtn = document.getElementById('searchBtn'), resultsBox = document.getElementById('results');
let searchMarker = null;

function escapeHtml(text) { return text.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[m]); }

async function searchPlace(query) {
  if (!query) return;
  loadingEl.style.display = 'block';
  let attempts = 0, maxAttempts = 2;
  while (attempts < maxAttempts) {
    try {
      const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`, {
        headers: { 'User-Agent': 'RDR2-Map-App/1.0' }
      });
      if (!res.ok) throw new Error('Search error: ' + res.status);
      const data = await res.json();
      showResults(data);
      break;
    } catch (e) {
      attempts++;
      console.warn(`Search attempt ${attempts} failed:`, e);
      if (attempts === maxAttempts) {
        alert('Search failed after retries. Please check your query or try again later.');
      } else {
        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s before retry
      }
    }
  }
  loadingEl.style.display = 'none';
}
function showResults(items) {
  if (!items || items.length === 0) { resultsBox.style.display = 'none'; resultsBox.innerHTML = ''; return; }
  resultsBox.style.display = 'block';
  resultsBox.innerHTML = items.map(it => {
    const display = it.display_name || (it.name || it.type || 'result');
    return `<div class="item" data-lat="${it.lat}" data-lon="${it.lon}" tabindex="0">${escapeHtml(display)}</div>`;
  }).join('');
  resultsBox.querySelectorAll('.item').forEach(el => {
    el.addEventListener('click', handleResultClick);
    el.addEventListener('keypress', e => { if (e.key === 'Enter') handleResultClick.call(el, e); });
  });
}
function handleResultClick() {
  const lat = parseFloat(this.dataset.lat), lon = parseFloat(this.dataset.lon);
  resultsBox.style.display = 'none';
  if (searchMarker) map.removeLayer(searchMarker);
  searchMarker = L.circleMarker([lat, lon], { radius: 8, fillColor: '#ffb36b', color: '#f1d8b0', weight: 2, fillOpacity: 0.95 }).addTo(map);
  map.setView([lat, lon], 15, { animate: true });
  routeTo(lat, lon);
}
searchBtn.addEventListener('click', () => searchPlace(searchInput.value));
searchInput.addEventListener('keypress', e => { if (e.key === 'Enter') searchPlace(searchInput.value); });

// --- Routing ---
let routeLayer = null;
async function routeTo(lat, lng) {
  if (!playerMarker.getLatLng()) {
    alert('Player location not available yet.');
    return;
  }
  loadingEl.style.display = 'block';
  const start = playerMarker.getLatLng();
  const apiKey = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjVjODRmZmE2Mzk2NzQ5NTA5YWYxMjgxOTMzNDY1NTE2IiwiaCI6Im11cm11cjY0In0='; // Replace with your actual key from https://openrouteservice.org/
  const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${start.lng},${start.lat}&end=${lng},${lat}`;
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('Routing error: ' + res.status + '. Check API key.');
    const data = await res.json();
    if (routeLayer) map.removeLayer(routeLayer);
    const coords = data.features[0].geometry.coordinates.map(c => [c[1], c[0]]);
    routeLayer = L.polyline(coords, { color: '#ff0000', weight: 5, opacity: 0.85, dashArray: null, lineCap: 'round' }).addTo(map);
    map.fitBounds(routeLayer.getBounds(), { padding: [40, 40] });
    const summary = data.features[0].properties.summary;
    routeLayer.bindPopup(`Distance: ${(summary.distance / 1000).toFixed(1)} km<br>Duration: ${(summary.duration / 60).toFixed(0)} min`).openPopup();
  } catch (e) {
    console.warn(e);
    alert('Routing failed. Ensure you have a valid API key and try again.');
  } finally {
    loadingEl.style.display = 'none';
  }
}

// --- Clear Route Button ---
document.getElementById('clearRoute').addEventListener('click', () => {
  if (routeLayer) {
    map.removeLayer(routeLayer);
    routeLayer = null;
  }
  if (searchMarker) {
    map.removeLayer(searchMarker);
    searchMarker = null;
  }
});

// --- Recenter Button ---
document.getElementById('recenter').addEventListener('click', () => {
  if (playerMarker.getLatLng()) map.setView(playerMarker.getLatLng(), 16, { animate: true });
});
</script>
</body>
</html>